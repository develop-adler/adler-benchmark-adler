import{BufferAttribute as e,BufferGeometry as t,Float32BufferAttribute as r,InstancedBufferAttribute as i,InterleavedBuffer as o,InterleavedBufferAttribute as n,TriangleFanDrawMode as u,TriangleStripDrawMode as s,TrianglesDrawMode as l,Vector3 as a}from"three";function computeMikkTSpaceTangents(t,r,i=!0){if(!r||!r.isReady)throw Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(e){if(e.normalized||e.isInterleavedBufferAttribute){let t=new Float32Array(e.count*e.itemSize);for(let r=0,i=0;r<e.count;r++)t[i++]=e.getX(r),t[i++]=e.getY(r),e.itemSize>2&&(t[i++]=e.getZ(r));return t}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}let n=t.index?t.toNonIndexed():t,u=r.generateTangents(o(n.attributes.position),o(n.attributes.normal),o(n.attributes.uv));if(i)for(let s=3;s<u.length;s+=4)u[s]*=-1;return n.setAttribute("tangent",new e(u,4)),t!==n&&t.copy(n),t}function mergeGeometries(e,r=!1){let i=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),u={},s={},l=e[0].morphTargetsRelative,a=new t,f=0;for(let m=0;m<e.length;++m){let g=e[m],d=0;if(i!==(null!==g.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let b in g.attributes){if(!o.has(b))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+'. All geometries must have compatible attributes; make sure "'+b+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[b]&&(u[b]=[]),u[b].push(g.attributes[b]),d++}if(d!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". Make sure all geometries have the same number of attributes."),null;if(l!==g.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let c in g.morphAttributes){if(!n.has(c))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[c]&&(s[c]=[]),s[c].push(g.morphAttributes[c])}if(r){let h;if(i)h=g.index.count;else{if(void 0===g.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+m+". The geometry must have either an index or a position attribute"),null;h=g.attributes.position.count}a.addGroup(f,h,m),f+=h}}if(i){let p=0,$=[];for(let A=0;A<e.length;++A){let y=e[A].index;for(let w=0;w<y.count;++w)$.push(y.getX(w)+p);p+=e[A].attributes.position.count}a.setIndex($)}for(let B in u){let x=mergeAttributes(u[B]);if(!x)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+B+" attribute."),null;a.setAttribute(B,x)}for(let E in s){let T=s[E][0].length;if(0===T)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[E]=[];for(let G=0;G<T;++G){let z=[];for(let v=0;v<s[E].length;++v)z.push(s[E][v][G]);let I=mergeAttributes(z);if(!I)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+E+" morphAttribute."),null;a.morphAttributes[E].push(I)}}return a}function mergeAttributes(t){let r,i,o,n=-1,u=0;for(let s=0;s<t.length;++s){let l=t[s];if(l.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=l.array.constructor),r!==l.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===i&&(i=l.itemSize),i!==l.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=l.normalized),o!==l.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===n&&(n=l.gpuType),n!==l.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;u+=l.array.length}let a=new r(u),f=0;for(let m=0;m<t.length;++m)a.set(t[m].array,f),f+=t[m].array.length;let g=new e(a,i,o);return void 0!==n&&(g.gpuType=n),g}export function deepCloneAttribute(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?deinterleaveAttribute(t):t.isInstancedBufferAttribute?new i().copy(t):new e().copy(t)}function interleaveAttributes(e){let t,r=0,i=0;for(let u=0,s=e.length;u<s;++u){let l=e[u];if(void 0===t&&(t=l.array.constructor),t!==l.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=l.array.length,i+=l.itemSize}let a=new o(new t(r),i),f=0,m=[],g=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let b=0,c=e.length;b<c;b++){let h=e[b],p=h.itemSize,$=h.count,A=new n(a,p,f,h.normalized);m.push(A),f+=p;for(let y=0;y<$;y++)for(let w=0;w<p;w++)A[d[w]](y,h[g[w]](y))}return m}export function deinterleaveAttribute(t){let r=t.data.array.constructor,o=t.count,n=t.itemSize,u=t.normalized,s=new r(o*n),l;l=t.isInstancedInterleavedBufferAttribute?new i(s,n,u,t.meshPerAttribute):new e(s,n,u);for(let a=0;a<o;a++)l.setX(a,t.getX(a)),n>=2&&l.setY(a,t.getY(a)),n>=3&&l.setZ(a,t.getZ(a)),n>=4&&l.setW(a,t.getW(a));return l}export function deinterleaveGeometry(e){let t=e.attributes,r=e.morphTargets,i=new Map;for(let o in t){let n=t[o];n.isInterleavedBufferAttribute&&(i.has(n)||i.set(n,deinterleaveAttribute(n)),t[o]=i.get(n))}for(let u in r){let s=r[u];s.isInterleavedBufferAttribute&&(i.has(s)||i.set(s,deinterleaveAttribute(s)),r[u]=i.get(s))}}function estimateBytesUsed(e){let t=0;for(let r in e.attributes){let i=e.getAttribute(r);t+=i.count*i.itemSize*i.array.BYTES_PER_ELEMENT}let o=e.getIndex();return t+(o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0)}function mergeVertices(t,r=1e-4){r=Math.max(r,Number.EPSILON);let i={},o=t.getIndex(),n=t.getAttribute("position"),u=o?o.count:n.count,s=0,l=Object.keys(t.attributes),a={},f={},m=[],g=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let b=0,c=l.length;b<c;b++){let h=l[b],p=t.attributes[h];a[h]=new e(new p.array.constructor(p.count*p.itemSize),p.itemSize,p.normalized);let $=t.morphAttributes[h];$&&(f[h]=new e(new $.array.constructor($.count*$.itemSize),$.itemSize,$.normalized))}let A=.5*r,y=Math.log10(1/r),w=Math.pow(10,y),B=A*w;for(let x=0;x<u;x++){let E=o?o.getX(x):x,T="";for(let G=0,z=l.length;G<z;G++){let v=l[G],I=t.getAttribute(v),S=I.itemSize;for(let _=0;_<S;_++)T+=`${~~(I[g[_]](E)*w+B)},`}if(T in i)m.push(i[T]);else{for(let R=0,U=l.length;R<U;R++){let X=l[R],H=t.getAttribute(X),k=t.morphAttributes[X],M=H.itemSize,V=a[X],N=f[X];for(let Y=0;Y<M;Y++){let Z=g[Y],P=d[Y];if(V[P](s,H[Z](E)),k)for(let D=0,W=k.length;D<W;D++)N[D][P](s,k[D][Z](E))}}i[T]=s,m.push(s),s++}}let C=t.clone();for(let L in t.attributes){let q=a[L];if(C.setAttribute(L,new e(q.array.slice(0,s*q.itemSize),q.itemSize,q.normalized)),L in f)for(let O=0;O<f[L].length;O++){let j=f[L][O];C.morphAttributes[L][O]=new e(j.array.slice(0,s*j.itemSize),j.itemSize,j.normalized)}}return C.setIndex(m),C}function toTrianglesDrawMode(e,t){if(t===l)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t!==u&&t!==s)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e;{let r=e.getIndex();if(null===r){let i=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let n=0;n<o.count;n++)i.push(n);e.setIndex(i),r=e.getIndex()}let a=r.count-2,f=[];if(t===u)for(let m=1;m<=a;m++)f.push(r.getX(0)),f.push(r.getX(m)),f.push(r.getX(m+1));else for(let g=0;g<a;g++)g%2==0?(f.push(r.getX(g)),f.push(r.getX(g+1)),f.push(r.getX(g+2))):(f.push(r.getX(g+2)),f.push(r.getX(g+1)),f.push(r.getX(g)));f.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let d=e.clone();return d.setIndex(f),d.clearGroups(),d}}function computeMorphedAttributes(e){let t=new a,i=new a,o=new a,n=new a,u=new a,s=new a,l=new a,f=new a,m=new a;function g(e,r,a,g,d,b,c,h){t.fromBufferAttribute(r,d),i.fromBufferAttribute(r,b),o.fromBufferAttribute(r,c);let p=e.morphTargetInfluences;if(a&&p){l.set(0,0,0),f.set(0,0,0),m.set(0,0,0);for(let $=0,A=a.length;$<A;$++){let y=p[$],w=a[$];0!==y&&(n.fromBufferAttribute(w,d),u.fromBufferAttribute(w,b),s.fromBufferAttribute(w,c),g?(l.addScaledVector(n,y),f.addScaledVector(u,y),m.addScaledVector(s,y)):(l.addScaledVector(n.sub(t),y),f.addScaledVector(u.sub(i),y),m.addScaledVector(s.sub(o),y)))}t.add(l),i.add(f),o.add(m)}e.isSkinnedMesh&&(e.applyBoneTransform(d,t),e.applyBoneTransform(b,i),e.applyBoneTransform(c,o)),h[3*d+0]=t.x,h[3*d+1]=t.y,h[3*d+2]=t.z,h[3*b+0]=i.x,h[3*b+1]=i.y,h[3*b+2]=i.z,h[3*c+0]=o.x,h[3*c+1]=o.y,h[3*c+2]=o.z}let d=e.geometry,b=e.material,c,h,p,$=d.index,A=d.attributes.position,y=d.morphAttributes.position,w=d.morphTargetsRelative,B=d.attributes.normal,x=d.morphAttributes.position,E=d.groups,T=d.drawRange,G,z,v,I,S,_,R,U=new Float32Array(A.count*A.itemSize),X=new Float32Array(B.count*B.itemSize);if(null!==$){if(Array.isArray(b))for(G=0,v=E.length;G<v;G++)for(_=Math.max((S=E[G]).start,T.start),R=Math.min(S.start+S.count,T.start+T.count),z=_,I=R;z<I;z+=3)c=$.getX(z),g(e,A,y,w,c,h=$.getX(z+1),p=$.getX(z+2),U),g(e,B,x,w,c,h,p,X);else for(_=Math.max(0,T.start),R=Math.min($.count,T.start+T.count),G=_,v=R;G<v;G+=3)c=$.getX(G),g(e,A,y,w,c,h=$.getX(G+1),p=$.getX(G+2),U),g(e,B,x,w,c,h,p,X)}else if(Array.isArray(b))for(G=0,v=E.length;G<v;G++)for(_=Math.max((S=E[G]).start,T.start),R=Math.min(S.start+S.count,T.start+T.count),z=_,I=R;z<I;z+=3)c=z,g(e,A,y,w,c,h=z+1,p=z+2,U),g(e,B,x,w,c,h,p,X);else for(_=Math.max(0,T.start),R=Math.min(A.count,T.start+T.count),G=_,v=R;G<v;G+=3)c=G,g(e,A,y,w,c,h=G+1,p=G+2,U),g(e,B,x,w,c,h,p,X);let H=new r(U,3),k=new r(X,3);return{positionAttribute:A,normalAttribute:B,morphedPositionAttribute:H,morphedNormalAttribute:k}}function mergeGroups(e){if(0===e.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),e;let t=e.groups;if(t=t.sort((e,t)=>e.materialIndex!==t.materialIndex?e.materialIndex-t.materialIndex:e.start-t.start),null===e.getIndex()){let r=e.getAttribute("position"),i=[];for(let o=0;o<r.count;o+=3)i.push(o,o+1,o+2);e.setIndex(i)}let n=e.getIndex(),u=[];for(let s=0;s<t.length;s++){let l=t[s],a=l.start,f=a+l.count;for(let m=a;m<f;m++)u.push(n.getX(m))}e.dispose(),e.setIndex(u);let g=0;for(let d=0;d<t.length;d++){let b=t[d];b.start=g,g+=b.count}let c=t[0];e.groups=[c];for(let h=1;h<t.length;h++){let p=t[h];c.materialIndex===p.materialIndex?c.count+=p.count:(c=p,e.groups.push(c))}return e}function toCreasedNormals(t,r=Math.PI/3){let i=Math.cos(r),o=(1+1e-10)*100,n=[new a,new a,new a],u=new a,s=new a,l=new a,f=new a;function m(e){let t=~~(e.x*o),r=~~(e.y*o),i=~~(e.z*o);return`${t},${r},${i}`}let g=t.index?t.toNonIndexed():t,d=g.attributes.position,b={};for(let c=0,h=d.count/3;c<h;c++){let p=3*c,$=n[0].fromBufferAttribute(d,p+0),A=n[1].fromBufferAttribute(d,p+1),y=n[2].fromBufferAttribute(d,p+2);u.subVectors(y,A),s.subVectors($,A);let w=new a().crossVectors(u,s).normalize();for(let B=0;B<3;B++){let x=n[B],E=m(x);E in b||(b[E]=[]),b[E].push(w)}}let T=new Float32Array(3*d.count),G=new e(T,3,!1);for(let z=0,v=d.count/3;z<v;z++){let I=3*z,S=n[0].fromBufferAttribute(d,I+0),_=n[1].fromBufferAttribute(d,I+1),R=n[2].fromBufferAttribute(d,I+2);u.subVectors(R,_),s.subVectors(S,_),l.crossVectors(u,s).normalize();for(let U=0;U<3;U++){let X=n[U],H=m(X),k=b[H];f.set(0,0,0);for(let M=0,V=k.length;M<V;M++){let N=k[M];l.dot(N)>i&&f.add(N)}f.normalize(),G.setXYZ(I+U,f.x,f.y,f.z)}}return g.setAttribute("normal",G),g}function mergeBufferGeometries(e,t=!1){return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."),mergeGeometries(e,t)}function mergeBufferAttributes(e){return console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."),mergeAttributes(e)}export{computeMikkTSpaceTangents,mergeGeometries,mergeBufferGeometries,mergeAttributes,mergeBufferAttributes,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals};